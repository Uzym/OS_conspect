# ОСИ #
***Миронов Евгений Сергеевич*** *m_ec@mail.ru*

## Правила

**StdThread** – использовать нельзя (C++)
**Posix/WinApi** - использовать

## Литература
1. Таненбаум "Современные операционные системы. Разработка и реализация"
2. Вахалия "UNIX изнутри"

## Типы ОС
это программа чел
### типы
1. мейнфрейм (решает только одну задачу)
2. серверная ОС (дольше переключается между процессами)
3. пользовательская (UI важен)
4. Многопроцессорная ОС
5. Мобильная ОС (уменьшение потребление энергии)
6. Встроенная ОС (ОС банкоматов например (сильно урезанная операционная система)) также называется embaded
7. ОС сенсорных узлов (например камеры)
8. ОС реального времени (предсказуемость главное, решает только наборы специфичных задач)
9. ОС смарт-карт (типа банковских карт)

### Как они могут быть устроенны
1. монолитные (Windows, очень много взаимосвязей)
2. многоуровневые (каждый уровень общается только с соседними)
3. микроядерная (То к чему идёт Linux, каждый процесс может быть удалён, то же самое что и микросервисная архетектура)
4. Клиент-Серверная
5. виртуальная машина (ниже производительность)  

## Зачем они нужны?
*функции*:
1. прослойка между всяким железом и программистом (создаёт api для железа)
2. Управление ресурсами компьютера
3. Работа с ЦП (многопоточность)

### Память
1. регистры        |
2. кэш             |
3. ОЗУ             |
4. ПЗУ (SSD, HDD)  |
5. магнитные ленты V (Скорость работы падает)

### Системный вызов

*подразделения системных вызовов*
1. работа с процессами
2. управление файлами/каталогами
3. остальное (безопастность, работа с пользователями)

## Процесс

**программа** 	./a.out -> ... -> Результат
				Программа 1-N Процесс (у одной программы может быть много процессов)
**процесс** input -> output -|-> out -> file
							 |-> error

стек -> данные (перекочевало в кучу), текст <- ЦП
	f(1, 2, 3) Basepointer(BP) - номер в стеке, Stackpointer(SP) - где находится в памяти стека начало данных
	|1, BP, адрес возврата, 1, 2, 3, ...|

### появление процесса
1. a.out -> b.out
2. user -> a.out
### смерть процесса
1. return 0;
2. return -1;
3. seckfall/stack overflow
4. процесс убивате процесс

### особенности UNIX
1. зомби-процессы и процессы-сироты
2. процессы создаются с помощью fork()
	1. a.out -> fork() -+-> a.out
						+-> a'.out
	2. fork() возвращает id процесса
		1. если >0 то процесс родительский
		2. если <0 то процесс дочерний
	3. fork() блокирующий процесс
3. exec() - перезаписывает текущий процесс новой программой

#### Таблица процессов
ОНА КОНЕЧНА (```while(true) int id = fork();``` форк-бомба)

### особенности Windows
1. CreateProcess(...) (9 АРГУМЕНТОВ)

### Действия
|-> блокировка -> готовность <-> действия
|--------------------------------|

### PIPE
*PIPEs* ls -la |(вот это вот PIPEs или же конвеер) grep 1.txt

input -> ls -> output -> PIPE -> input -> grep -> output

#### Препарируем PIPE
input -> PIPE -> output
	write(in) read(out)

#### Как создавать
**Windows** 
CreatePipe(...)
**Linux** 
```c
int fd[2]; 
int res = pipe(fd); 
// fd[0] - In, fd[1] - Out

int x = 15;
write(fd[0], &x, sizeof(x));

int y;
read(fd[1], &y, sizeof(y));
```
dub2(...) - переопределние out
```c
int fd[2];
int res = pipe(fd);
int id = fork();
if (id > 0) {
	dup2(stdout, fd[0]);
} else {
	dub2(stdin, fd[1]);
}
```
**НЕОБХОДИМО ЗАКРЫВАТЬ PIPE**

### 1 лаба
**Linux** strace - утилита для трассирования или мониторинга системных вызовов

#### А зачем это нужно?
а чтобы ошибки искать

## Параллельные процессы
T1 - время на 1 процессоре\
Tp - время на p процессорах

**ускорение:**
$$ S_p = T_1/T_p <= p $$
$$ S_p <= 1/(alp + (1 - alp)/p) $$
где alp - процент программы который распаралеллить нельзя 

(например чтение)

## Поток
Stream I/O отличается от Thread
Память 1 -> N Поток
Начало от **main**
**create_thread** - создать поток в Линукс. библиотека **pthread**
```c++
#include <pthread>
void sum(void *param){
	...
}

int main() {
	create_thread(/*ссылка на функцию*/);
	detach(thread1); // ОС не будет ждать выполнения
	join(thread2); // поток main остоновится ожидая thread2, так почистит системную информацию
}
```
### типы потоков
1. foneground - процесс не завершается пока хотя бы один поток работает
2. background - процессу всё равно

### Пример
```c++
stdint_ x;
void increment() {
	x = x + 1;
}
create_thread(&increment);
create_thread(&increment);
```
может возникнуть ошибка при попытки перезаписи x
они попытаются обогнать друг-друга в записи

#### Как решить
```c++
stdint_ x;
void increment() {
	enterRegion();
	x = x + 1;
	leaveRegion();
}
create_thread(&increment);
create_thread(&increment);
```

```c++
enterRegion() {
	while(x != 0);
	//x <- 1
}
leaveRegion() {
	//x <- 0
}
``` 
Создали общий паттерн **TSL** библиотека **atomic**
TSL возвращает предыдущее значение (по сути делает операцию присваивания)
```c++
enterRegion() {
	while(TSL(1) != 0); // называется активным ожиданием
	//x <- 1
}
leaveRegion() {
	TSL(0);
	//x <- 0
}
``` 

##### Приостановка и активизация
останавливает выполнение потока пока его не активизируют
1. Mutex (в линуксе pthread_mutex) {состояния: open и lock}:
	1. ``lock(m)`` -> ``while(TSL(1) != 1)``
	2. ``unlock(m)``
2. Семафор {состояния: 0, ..., n}
3. Барьер - пока все потоки не дойдут до отмеченной точки.
	```c++
	int main() {
		x + threadHandler[...];
		for (i..o..n)
			threadHandler[i] = createThread();
		
		/*тут какие то вычисления*/
		
		for (i..o..n)
			join(threadHandler[i]);

	}
	```
### Примитивы синхронизации
#### Conditional variable 
(в ``C#`` и ``Java`` называются мониторами).
```c++
Get(...) { // получить значение
	lock();
	if (storage == 0) {
		wait(used_val);
		lock_variable(used_val);
	}
	storage --;
	unlock();
}
```
```c++
Put(...) { // вставить значение
	lock();
	storage ++;
	pulse()
	unlock_variable(used_var);
	unlock();
}
```
## Тема о том что всё **плохо**
Всё ок
```c++
lock(m1);
lock(m2);
lock(m3);
...
unlock(m1);
unlock(m2);
...
```
НИЧЕГО НЕ ОК
```c++
lock(m2);
lock(m1);
...
unlock(m1);
unlock(m2);
```
называется взаимоблокирока или же ``deadlock``.
### Случаи возникновления
>Просто совет: не используйте оптимизацию кода, так будет гораздо легче дебажить

1. надо дополнить

**КАК ЖЕ ИСПРАВИТЬ???**:
1. Не исправлять
2. Заиметь граф который будет детектить такие ошибки
- Если нашли один из потоков который блочит другой, то можно снести менее приорететный (так делают некоторые СУБД).
- Также можно просто немного откатиться назад.

Ещё может быть **зависание** - это когда одна задача более приоритетна чем другая, а менее приоритетная должна заканчивать более приоритетный.

## Планирование процесса

Ресурсов не хватает, поэтому поделим ресурсы! Из-за этого может создаваться ощущение что всё работает в реалтайме.

Что именно планируется
1. Когда процесс стартует и с какими параметрами.
2. Заверешение процесса
3. Блокирование
4. Ожидание ввода-вывода (очень важно для пользователя)

### Пакетные системы
Так работает система выдачи заказов в маке.

**оборотное время** 
$$ (N_0t_1+(N_0-1)t_2+...)/N $$

Вперёд самую лёгкую задачу

**Прогноз по времени**
$$ t: t_11/2 + t_21/4 + ... + t_n1/2^n $$
Расчет времени выполнения одной задачи на основе опыта её запуска.

### Интерактивные системы
1. Циклическая обработка $$p_1 -> p_2 -> p_3 -> p_1 -> ...$$
2. p -> exec -> ... (тут прослушал)
3. Несколько очередей по приоритету
4. Гарантированное планирование (если процесс работал определённое время, то другие процессы начнут работу на такое же время), так определяется квант времени для разных приоритетов задач.
5. Лотерейная планирование (Куда поподёт рандом то и выполнять)
$$ p_1(a) = 50_{билетиков}, p_2(b) = 25_{билетиков}, p_3(c) = 5_{билетиков}
$$
6. Бригадное планирование (честно не понял че это)
	```
	A1, A2, A3
	B1, B2
	C1
	D1, D2
	```

### Системы реального времени
Запускают определённые пакеты задач в определённое время
(чет сложное лучше прочитать у Таненбаума)
1. **EDF** - Брать задачу у которой самый близкий дедлайн
2. **RMS**

## Приоритеты
2 очереди пиздец ниче не написал

## Файл
Логический информационный блок который был создан процессором
- Имеет структуру
	- имя
	- длинна
	- регистр (не?)зависимость `ABc.txt =(?) abc.txt`
	- расширение
- Структура файла
	- non/dublicated
	- записей -> БД
	- дерева
- Операции
	- Создать/удалить/переименовать
	- Записать/Читать
	- Открыть/Закрыть
	- Передвигаться
	- Атрибуты
- Каталоги
	- Уровень
		- Одноуровневые
		- Многоуровневые
	- имена файлов
		- абсолютные `/home/analny_caratel/.../strapon_porno_ebyt_negra.mp3`
		- относительные `./porno_sex/strapon_porno_ebyt_negra.mp3`
	- Операции
		- Создать/удалить/переименовать
		- Открыть/Закрыть
		- Link/Unlink

`mmap` - отобразить файл в ОЗУ
$$ ... $$
